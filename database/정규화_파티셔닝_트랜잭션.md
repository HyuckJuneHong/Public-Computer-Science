> **<목차>**  
> 1. 정규화와 비정규화  
> 2. 정규화 과정  
> 3. 파티셔닝  
> 4. SQL Injection  
> 5. 트랜잭션

---

## 정규화

중복 최소화 및 이상현상 제어를 위해 테이블을 작게 분해하는 작업

**장점** : 테이블 크기가 작아져 저장 공간 최소화

**단점** : 테이블간 연산이 많아진다.

## 비정규화(=반정규화)

시스템 성능 향상 혹은 개발 및 운영의 편의성 등을 위해 정규화 데이터 모델을 통합, 중복, 분리하는 과정

**장점** : 조인 비용을 줄인다.

**단점** : 데이터 일관성이 꺠지고 갱신, 삽입 비용 증가.

> ****<참고 : 이상현상>****
>
> 삽입이상 : 불필요한 데이터를 추가해야만 삽입이 가능한 상황  
> 갱신이상 : 튜플의 일부만 갱신되는 상황  
> 삭제이상 : 삭제로 인해 필요한 데이터까지 함께 삭제되는 현상 (연쇄 삭제)

---

## 정규화 과정

**제 1 정규화**

-   모든 속성값을 원자값으로 설정
-   즉, 도메인이 원자값이다.

**제 2 정규화**

-   제 1 정규화를 지키며, 부분 함수 종속 제거
-   즉, 완전 함수 종속으로 만든다.
-   예로 PK를 제외한 모든 속성값이 다른 속성을 결정하지 못하게 만든다.

> **<참고 : 함수 종속>**  
> 부분 함수 종속 : 기본키의 일부에 종속될 수 있다.  
> 완전 함수 종속 : 기본키의 부분집합이 결정자가 되지 않는다.

**제 3 정규화**

-   제 2 정규화를 지키며, 이행적 함수 종속 제거

> **<참고 : 이행적 함수 종속>**  
> A->B, B->C 일 때, A->C이다.

**BCNF**

-   모든 결정자는 후보키 집합에 속하도록 한다.

---

## 파티셔닝

디비의 규모가 커지면서 기존 디비에 용량과 성능 문제 발생 시 사용.

수직 파티셔닝

-   테이블이나 인덱스를 관리하기 쉬운 파티션이란 작은 단위로 분리적 분할하는 것.
-   물리적으로 분리되어 있어도 접근하는 쪽에서 인지 불가.
-   예를 들어, 하나의 엔티티를 2개 이상으로 분리
-   파티션 기준 : Partitioning Key 사용

**장점**

-   **성능적 측면** : 자주 사용하는 컬럼들 분리하여 I/O 측면에서 성능 이점  
    (파티션 단위로 조회 및 DML 수행 가능)
-   **관리적 측면** : 파티션 단위로 백업, 추가, 삭제 변경 가능

**단점**

-   테이블간 조인 비용 증가
-   테이블과 인덱스를 별도로 파티셔닝이 불가

#### 수평 파티셔닝

-   하나의 테이블의 각 행을 다른 테이블에 분산하는 것.
-   키를 기반으로 여러 곳에 분산

**장점** : 데이터 갯수를 기준으로 나눠 파티셔닝. 즉, 인덱스 갯수도 작아져 성능 향상.

**단점** : 조회 과정이 기존보다 복잡.

> **<참고 : 샤딩>**
> 
> 샤딩과 수평 파티셔닝은 매우 비슷.  
> 샤딩 : 분할 후 다른 디비에 저장  
> 수평 파티셔닝 : 분할 후 같은 디비에 저장

---

## SQL Injection

사용자의 입력값이 SQL 구문의 일부로 사용될 경우, 조작된 SQL 구문이 디비에 그대로 전달되어 비정상 명령을 실행시키는 공격 기법.

즉, 조작 SQL Query가 디비에 그대로 전달되어 비정상 명령 실행

**해결 방법**

1.  일정 키워드를 정해놓고 키워드가 있는 SQL문을 검증하는 방식
2.  입력값에 대한 검사를 하고 에러 메시지 노출을 하지 않도록 하는 방식
3.  PreparedStatment를 사용하는 방식 (권장)

> **<참고 : PreparedStatment>**  
> PreparedStatment에서 바인딩 데이터는 SQL 문법이 아닌 컴파일 언어로 처리.  
> 즉, 문법적 의미를 가지지 않기 때문에, 바인딩 변수에 SQL Injection Query를 넣어도 쿼리가 동작하지 않는다.
>
> **<참고 : JPA>**
> 
> JPA는 PreparedStatement처럼 동작하여 안전한 상태.  
> 즉, JPA는 PreparedStatement와 마찬가지로 파라미터를 바인딩하여 사용하기 때문에 SQL Injection으로부터 안전.

---

## 트랜잭션

데이터베이스의 상태를 변화시키는 하나의 논리작업 단위

이는 논리작업 쿼리 개수와 상관없이 논리작업 셋 자체가 100% 적용되거나 0% 적용됨을 보장.

#### ACID

**원자성(Atomicity)**

-   트랜잭션은 모두 성공적으로 완료 혹은 실패해야 한다.

**일관성(Consistency)**

-   트랜잭션 시작 전 및 후의 상태(제약조건)이 같아야 한다.
-   PK, FK 제약같은 명시적인 무결성 제약조건이 부합해야 한다.
-   즉, 트랜잭션 실행 성공 시 일관성 디비 상태 유지

**격리성(고립성, Isoation)**

-   트랜잭션이 어떤 자원을 사용하고 있는 동안 다른 트랜잭션 접근 불가
-   즉, 서로 다른 트랜잭션이 서로에게 영향을 주면 안된다.

**지속성(영구성, Durability)**

-   트랜잭션이 성공적으로 완료된 후 영구적으로 반영되어야 한다.
-   즉, 커밋된 트랜잭션 영구 반영

---

## 트랜잭션 상태

**활동(Ative) :** 트랜잭션 실행 중인 상태

**장애(Fail)** : 트랜잭션 실행 중 오류가 발생하여 중단한 상태

**철회(Aborted)** : 트랜잭션이 비정상 종료되어 Rollback 수행하는 상태

**부분 완료(Partially Commit)** : 마지막 연산까지 실행하고, Commit 연산이 실행되기 직전인 상태

**완료(Committed)** : 트랜잭션이 성공적으로 종료되어 Commit 연산을 실행한 후의 상태